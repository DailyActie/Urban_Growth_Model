extensions [gis]


globals [
  themap
  urban-dataset
  slope-dataset
  road-dataset
  dispersion_value  ;;used in spontaneous growth
  rg_value  ;;road gravity value, used to calculate max_search
  max_search  ;;used in road influenced growth
  prob_to_build ;;a lookup table of the probability to urbanize based on slope
  max_slope
  
  
]

patches-own[
 urban   ;;binary, if it is urbanized or not
 new_urbanized  ;;binary, if it is newly urbanized or not
 road  ;;binary, if there is a road or not
 road1 ;;includes information on road type from 1 to 4
 spread_center ;;binary

 road_found  ;;binary
 road_pixel  ;;the road poxel that an urbanized cell finds in road influenced growth

 slope  
 suitable   ;;binary, if it is suitable for urbanization
 
 run_value ;;the maximum number of steps traveled along the road network by an urban pixel
 washere ;;binary, marks the patches that have been stepped on in road infulence
 
 selected ;;1 if a road patch is selected to be the next step in a road trip 
    
]
  
turtles-own[
]


to setup
  ca 
  reset-ticks
  
  let maxy Map-height / 2
  let miny 0 - maxy
  let maxx int ((531 / 394) * maxy)  ;;531 / 394 is the size of the data
  let minx 0 - maxx
  resize-world minx maxx miny maxy
  
  load_data
  
  set dispersion_value (dispersion_coefficient * 0.005) * (world-width ^ 2 + world-height ^ 2) ^ 0.5
  set rg_value (rg_coefficient / max_coefficient * ((world-width + world-height) / 16.0 ))
  set max_search 4 * (rg_value * (1 + rg_value))
  
  check_suitability  
  check_road
  
  ask patches with [road = 1][set run_value road1 / 4 * dispersion_coefficient]
  ask patches [set road_found 0 set road_pixel nobody]
    
  if show_roads [ask patches with [road = 1] [set pcolor yellow]]
end
 
to go
  spontaneous_growth
  print "spontaneous_growth finished"
  new_spreading_center_growth
  print "new_spreading_center_growth finished"
  edge_growth
  print "edge_growth finished"
  if road_influence [print "running road_influenced_growth..." 
                     road_influenced_growth] ;;this process could be very slow
  print "road_influenced_growth finished"
  
  ifelse show_roads [
    ask patches with [urban = 1 and road = 0] [set pcolor brown]
    ask patches with [urban = 0 and road = 0] [set pcolor green]
    ask patches with [road = 1] [set pcolor yellow]]
      [ask patches with [urban = 1] [set pcolor brown]
       ask patches with [urban = 0] [set pcolor green]]
  tick
end


  to load_data
    ;;gis:load-coordinate-system "data/WGS_84_Geographic.prj"
    set urban-dataset gis:load-dataset "data/urban_santafe.asc"
    
    set slope-dataset gis:load-dataset "data/slope_santafe.asc"
    
    set road-dataset gis:load-dataset "data/road1_santafe.asc"
    
    gis:set-world-envelope-ds gis:envelope-of urban-dataset
    
   gis:apply-raster urban-dataset urban
   ask patches [ifelse urban = 2 [set urban 1 set pcolor brown][set urban 0 set pcolor green]  ]
   
   gis:apply-raster slope-dataset slope
   
   gis:apply-raster road-dataset road1

       
end 


to spontaneous_growth
  let i 0
  while [i < dispersion_value]
     [ let w (random (world-width - 1)) - (world-width - 1) * 0.5
       let h (random (world-height - 1)) - (world-height - 1) * 0.5
       ask patch w h [
         if urban = 0 and suitable = 1 [set urban 1 set new_urbanized 1]
       ]
       set i i + 1
     ]
  end

to new_spreading_center_growth
  let i 0
  ask patches with [new_urbanized = 1]
      [ let x random max_coefficient
        if x < breed_coefficient [ 
          ask n-of 2 neighbors [
            if urban = 0 and suitable = 1
               [set urban 1 set new_urbanized 1]]
               
            ]
        set new_urbanized 0
      ]
end

to edge_growth
  ask patches with [urban = 1]
     [let x random max_coefficient
       if ( x < spread_coefficient) and ( count neighbors with [urban = 1] > 1 ) and (count neighbors with [urban = 0] > 0)
         [ask n-of 1 neighbors with [urban = 0]
               [if suitable = 1 [set urban 1 set new_urbanized 1] ]
         ]]
end
  
to road_influenced_growth 
  ask patches with [urban = 1]
     [let x random max_coefficient
       if  x < breed_coefficient
          [ road_seeking
            if road_found = 1 [
              let i 1
              while [i < run_value][
                ask road_pixel [ 
                  set washere 1
                  if count neighbors4 with [road = 1 and washere = 0] > 0 [
                    ask one-of neighbors4 with [road = 1 and washere = 0][
                       ifelse count neighbors with [urban = 0 and suitable = 1] > 0
                               [ask one-of neighbors with [urban = 0 and suitable = 1][set urban 1 set new_urbanized 1 set pcolor brown
                                set i run_value]]
                               [set selected 1]]]]
                if count patches with [selected = 1] > 1 [print "ERROR"] 
                ask patches with [selected = 1] [ask myself [set road_pixel myself]]
                ask road_pixel [set selected 0]
                            set i i + 1] 
                      ]]]
end

to road_seeking
  set road_pixel nobody
  set road_found 0
   set road_pixel one-of patches with [road = 1] in-radius max_search 
   ifelse road_pixel = nobody [set road_found 0][set road_found 1]
end
  
    
     
to check_suitability
  ;;create lookup table
  set max_slope max [slope] of patches
  set prob_to_build []
  let i 0
  while [i <= critical_slope][
      let val (critical_slope - i) / critical_slope
      set prob_to_build lput (val ^ (slope_coefficient / 200)) prob_to_build
      set i i + 1]
  let j 1
  while [j <= (max_slope - critical_slope) ][
    set prob_to_build lput 0 prob_to_build  ;if slope > critical slope, the probability to urbanize is 0
    set j j + 1]
  ask patches [
    let x random-float 1
    ifelse x < item (slope) prob_to_build
        [set suitable 1][set suitable 0]]
end

to check_road
  ask patches [
    ifelse road1 > 0 [set road 1][set road 0]]
  end


to show_slope
    let min-slope gis:minimum-of slope-dataset
    let max-slope gis:maximum-of slope-dataset
    
    ask patches [if (slope <= 0) or (slope >= 0) 
         [set pcolor scale-color black slope min-slope max-slope]]
end

to show_suitable

  ask patches with [suitable = 1]
    [set pcolor white]
  ask patches with [suitable = 0]
    [set pcolor black]
end

to show_map
  ifelse show_roads [
    ask patches with [urban = 1 and road = 0] [set pcolor brown]
    ask patches with [urban = 0 and road = 0] [set pcolor green]
    ask patches with [road = 1] [set pcolor yellow]]
      [ask patches with [urban = 1] [set pcolor brown]
       ask patches with [urban = 0] [set pcolor green]]
end
  
